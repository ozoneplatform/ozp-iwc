<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/js/common/apiPromiseMixin.js - ozpIwc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="ozpIwc" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.1.18</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ozpIwc.alert.html">ozpIwc.alert</a></li>
                                <li><a href="../classes/ozpIwc.api.html">ozpIwc.api</a></li>
                                <li><a href="../classes/ozpIwc.api.base.Api.html">ozpIwc.api.base.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.base.Node.html">ozpIwc.api.base.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.data.Api.html">ozpIwc.api.data.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.data.node.Node.html">ozpIwc.api.data.node.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.data.node.Nodev2.html">ozpIwc.api.data.node.Nodev2</a></li>
                                <li><a href="../classes/ozpIwc.api.Endpoint.html">ozpIwc.api.Endpoint</a></li>
                                <li><a href="../classes/ozpIwc.api.EndpointRegistry.html">ozpIwc.api.EndpointRegistry</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadActionError.html">ozpIwc.api.error.BadActionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadContentError.html">ozpIwc.api.error.BadContentError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadRequestError.html">ozpIwc.api.error.BadRequestError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadResourceError.html">ozpIwc.api.error.BadResourceError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadStateError.html">ozpIwc.api.error.BadStateError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BaseError.html">ozpIwc.api.error.BaseError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoActionError.html">ozpIwc.api.error.NoActionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoMatchError.html">ozpIwc.api.error.NoMatchError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoPermissionError.html">ozpIwc.api.error.NoPermissionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoResourceError.html">ozpIwc.api.error.NoResourceError</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.base.html">ozpIwc.api.filter.base</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.Function.html">ozpIwc.api.filter.Function</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.standard.html">ozpIwc.api.filter.standard</a></li>
                                <li><a href="../classes/ozpIwc.api.intents.Api.html">ozpIwc.api.intents.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.intents.FSM.html">ozpIwc.api.intents.FSM</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Bound.html">ozpIwc.api.Lifespan.Bound</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Ephemeral.html">ozpIwc.api.Lifespan.Ephemeral</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Persistent.html">ozpIwc.api.Lifespan.Persistent</a></li>
                                <li><a href="../classes/ozpIwc.api.locks.Api.html">ozpIwc.api.locks.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.locks.Node.html">ozpIwc.api.locks.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.names.Api.html">ozpIwc.api.names.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.names.Node.html">ozpIwc.api.names.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.system.Api.html">ozpIwc.api.system.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.ApplicationNode.html">ozpIwc.api.system.node.ApplicationNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.ApplicationNodeV2.html">ozpIwc.api.system.node.ApplicationNodeV2</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.SystemNode.html">ozpIwc.api.system.node.SystemNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.UserNode.html">ozpIwc.api.system.node.UserNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.UserNodeV2.html">ozpIwc.api.system.node.UserNodeV2</a></li>
                                <li><a href="../classes/ozpIwc.apiMap.html">ozpIwc.apiMap</a></li>
                                <li><a href="../classes/ozpIwc.Client.html">ozpIwc.Client</a></li>
                                <li><a href="../classes/ozpIwc.Debugger.html">ozpIwc.Debugger</a></li>
                                <li><a href="../classes/ozpIwc.Lifespan.html">ozpIwc.Lifespan</a></li>
                                <li><a href="../classes/ozpIwc.log.html">ozpIwc.log</a></li>
                                <li><a href="../classes/ozpIwc.metric.Registry.html">ozpIwc.metric.Registry</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.BinaryHeap.html">ozpIwc.metric.stats.BinaryHeap</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.ExponentiallyDecayingSample.html">ozpIwc.metric.stats.ExponentiallyDecayingSample</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.Sample.html">ozpIwc.metric.stats.Sample</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.UniformSample.html">ozpIwc.metric.stats.UniformSample</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.BaseMetric.html">ozpIwc.metric.types.BaseMetric</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Counter.html">ozpIwc.metric.types.Counter</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Gauge.html">ozpIwc.metric.types.Gauge</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Histogram.html">ozpIwc.metric.types.Histogram</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Meter.html">ozpIwc.metric.types.Meter</a></li>
                                <li><a href="../classes/ozpIwc.network.KeyBroadcastLocalStorageLink.html">ozpIwc.network.KeyBroadcastLocalStorageLink</a></li>
                                <li><a href="../classes/ozpIwc.network.Peer.html">ozpIwc.network.Peer</a></li>
                                <li><a href="../classes/ozpIwc.packet.Fragment.html">ozpIwc.packet.Fragment</a></li>
                                <li><a href="../classes/ozpIwc.packet.FragmentStore.html">ozpIwc.packet.FragmentStore</a></li>
                                <li><a href="../classes/ozpIwc.packet.Network.html">ozpIwc.packet.Network</a></li>
                                <li><a href="../classes/ozpIwc.packet.Transport.html">ozpIwc.packet.Transport</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.elements.SecurityAttribute.html">ozpIwc.policyAuth.elements.SecurityAttribute</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PDP.html">ozpIwc.policyAuth.points.PDP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PIP.html">ozpIwc.policyAuth.points.PIP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PRP.html">ozpIwc.policyAuth.points.PRP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.utils.html">ozpIwc.policyAuth.points.utils</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.policies.html">ozpIwc.policyAuth.policies</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.PolicyCombining.html">ozpIwc.policyAuth.PolicyCombining</a></li>
                                <li><a href="../classes/ozpIwc.Timer.html">ozpIwc.Timer</a></li>
                                <li><a href="../classes/ozpIwc.transport.consensus.Base.html">ozpIwc.transport.consensus.Base</a></li>
                                <li><a href="../classes/ozpIwc.transport.consensus.Bully.html">ozpIwc.transport.consensus.Bully</a></li>
                                <li><a href="../classes/ozpIwc.transport.listener.SharedWorker.html">ozpIwc.transport.listener.SharedWorker</a></li>
                                <li><a href="../classes/ozpIwc.transport.PacketContext.html">ozpIwc.transport.PacketContext</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Base.html">ozpIwc.transport.participant.Base</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Client.html">ozpIwc.transport.participant.Client</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Debugger.html">ozpIwc.transport.participant.Debugger</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Internal.html">ozpIwc.transport.participant.Internal</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Multicast.html">ozpIwc.transport.participant.Multicast</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.MutexClient.html">ozpIwc.transport.participant.MutexClient</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.PostMessage.html">ozpIwc.transport.participant.PostMessage</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.RouterWatchdog.html">ozpIwc.transport.participant.RouterWatchdog</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.SharedWorker.html">ozpIwc.transport.participant.SharedWorker</a></li>
                                <li><a href="../classes/ozpIwc.transport.Router.html">ozpIwc.transport.Router</a></li>
                                <li><a href="../classes/ozpIwc.util.html">ozpIwc.util</a></li>
                                <li><a href="../classes/ozpIwc.util.AjaxPersistenceQueue.html">ozpIwc.util.AjaxPersistenceQueue</a></li>
                                <li><a href="../classes/ozpIwc.util.ApiPromiseMixin.html">ozpIwc.util.ApiPromiseMixin</a></li>
                                <li><a href="../classes/ozpIwc.util.AsyncAction.html">ozpIwc.util.AsyncAction</a></li>
                                <li><a href="../classes/ozpIwc.util.CancelableEvent.html">ozpIwc.util.CancelableEvent</a></li>
                                <li><a href="../classes/ozpIwc.util.Event.html">ozpIwc.util.Event</a></li>
                                <li><a href="../classes/ozpIwc.util.mutex.html">ozpIwc.util.mutex</a></li>
                                <li><a href="../classes/ozpIwc.util.object.html">ozpIwc.util.object</a></li>
                                <li><a href="../classes/ozpIwc.util.PacketRouter.html">ozpIwc.util.PacketRouter</a></li>
                                <li><a href="../classes/ozpIwc.wiring.html">ozpIwc.wiring</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ozpIwc.html">ozpIwc</a></li>
                                <li><a href="../modules/ozpIwc.api.html">ozpIwc.api</a></li>
                                <li><a href="../modules/ozpIwc.api.base.html">ozpIwc.api.base</a></li>
                                <li><a href="../modules/ozpIwc.api.data.html">ozpIwc.api.data</a></li>
                                <li><a href="../modules/ozpIwc.api.data.node.html">ozpIwc.api.data.node</a></li>
                                <li><a href="../modules/ozpIwc.api.error.html">ozpIwc.api.error</a></li>
                                <li><a href="../modules/ozpIwc.api.filter.html">ozpIwc.api.filter</a></li>
                                <li><a href="../modules/ozpIwc.api.intents.html">ozpIwc.api.intents</a></li>
                                <li><a href="../modules/ozpIwc.api.intents.node.html">ozpIwc.api.intents.node</a></li>
                                <li><a href="../modules/ozpIwc.api.locks.html">ozpIwc.api.locks</a></li>
                                <li><a href="../modules/ozpIwc.api.names.html">ozpIwc.api.names</a></li>
                                <li><a href="../modules/ozpIwc.api.system.html">ozpIwc.api.system</a></li>
                                <li><a href="../modules/ozpIwc.api.system.node.html">ozpIwc.api.system.node</a></li>
                                <li><a href="../modules/ozpIwc.metric.html">ozpIwc.metric</a></li>
                                <li><a href="../modules/ozpIwc.metric.stats.html">ozpIwc.metric.stats</a></li>
                                <li><a href="../modules/ozpIwc.metric.types.html">ozpIwc.metric.types</a></li>
                                <li><a href="../modules/ozpIwc.network.html">ozpIwc.network</a></li>
                                <li><a href="../modules/ozpIwc.packet.html">ozpIwc.packet</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.html">ozpIwc.policyAuth</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.elements.html">ozpIwc.policyAuth.elements</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.points.html">ozpIwc.policyAuth.points</a></li>
                                <li><a href="../modules/ozpIwc.transport.html">ozpIwc.transport</a></li>
                                <li><a href="../modules/ozpIwc.transport.consensus.html">ozpIwc.transport.consensus</a></li>
                                <li><a href="../modules/ozpIwc.transport.listener.html">ozpIwc.transport.listener</a></li>
                                <li><a href="../modules/ozpIwc.transport.participant.html">ozpIwc.transport.participant</a></li>
                                <li><a href="../modules/ozpIwc.util.html">ozpIwc.util</a></li>
                                <li><a href="../modules/ozpIwc.worker.html">ozpIwc.worker</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/js/common/apiPromiseMixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var ozpIwc = ozpIwc || {};
ozpIwc.util = ozpIwc.util || {};

/**
 * @module ozpIwc
 * @submodule ozpIwc.util
 */

ozpIwc.util.ApiPromiseMixin = (function (apiMap, log, util) {
    /**
     * @class ApiPromiseMixin
     * @namespace ozpIwc.util
     * @static
     * Augments a participant or connection that supports basic IWC communications
     * functions for sending and receiving.
     * @uses ozpIwc.util.Event
     * @param {ozpIwc.transport.participant.Base} participant
     * @param {Boolean} autoConnect
     */
    var ApiPromiseMixin = function (participant, autoConnect) {
        autoConnect = (typeof autoConnect === &quot;undefined&quot; || autoConnect);

        participant.address = participant.address || &quot;$nobody&quot;;
        participant.connect = participant.connect || function () {
                participant.connectPromise = Promise.resolve();
                return participant.connectPromise;
            };

        if (!participant.events) {
            participant.events = new util.Event();
            participant.events.mixinOnOff(participant);
        }

        var mixins = ApiPromiseMixin.getCore();
        for (var i in mixins) {
            participant[i] = mixins[i];
        }

        participant.readLaunchParams(util.globalScope.name);
        participant.readLaunchParams(util.globalScope.location.search);
        participant.readLaunchParams(util.globalScope.location.hash);

        ApiPromiseMixin.registerEvents(participant);

        participant.constructApiFunctions();

        if (autoConnect) {
            participant.connect();
        }
    };

    /**
     * Registers event listeners for the participant.  Listens for the following events: disconnect.
     * @method registerEvents
     * @static
     * @param {ozpIwc.transport.participant.Base} participant
     */
    ApiPromiseMixin.registerEvents = function (participant) {
        participant.on(&quot;disconnect&quot;, function () {
            participant.promiseCallbacks = {};
            participant.registeredCallbacks = {};
            util.globalScope.removeEventListener(&quot;message&quot;, participant.postMessageHandler, false);
            participant.connectPromise = null;
        });
    };

    /**
     * A factory for the apiPromise functionality.
     *
     * @method getCore
     * @static
     * @return {Object}
     */
    ApiPromiseMixin.getCore = function () {
        return {

            /**
             * @property promiseCallbacks
             * @type Object
             * @default {}
             */
            promiseCallbacks: {},

            /**
             * @property msgIdSequence
             * @type Number
             * @default 0
             */
            msgIdSequence: 0,

            /**
             * @property receivedPackets
             * @type Number
             * @default 0
             */
            receivedPackets: 0,

            /**
             * @property receivedBytes
             * @type Number
             * @default 0
             */
            receivedBytes: 0,

            /**
             * @property sentPackets
             * @type Number
             * @default 0
             */
            sentPackets: 0,

            /**
             * @property sentBytes
             * @type Number
             * @default 0
             */
            sentBytes: 0,

            /**
             * The epoch time the Client was instantiated.
             * @property startTime
             * @type Number
             */
            startTime: util.now(),

            /**
             * A map of available apis and their actions.
             * @property apiMap
             * @type Object
             */
            apiMap: apiMap || {},

            /**
             * @property wrapperMap
             * @type Object
             * @default {}
             */
            wrapperMap: {},

            /**
             * @property preconnectionQueue
             * @type Array
             * @default []
             */
            preconnectionQueue: [],

            /**
             * @property launchParams
             * @type Object
             * @default {}
             */
            launchParams: {},

            /**
             * @property watchMsgMap
             * @type Object
             * @default {}
             */
            watchMsgMap: {},

            /**
             * @property registeredCallbacks
             * @type Object
             * @default {}
             */
            registeredCallbacks: {},

            /**
             * @property launchedIntents
             * @type Array
             * @default []
             */
            launchedIntents: [],

            /**
             * Returns whether or not the participant is connected to the IWC bus.
             *
             * @method isConnected
             * @return {Boolean}
             */
            isConnected: function () {
                return this.address !== &quot;$nobody&quot;;
            },

            /**
             * Parses launch parameters based on the raw string input it receives.
             *
             * @method readLaunchParams
             * @param {String} rawString
             */
            readLaunchParams: function (rawString) {
                // of the form ozpIwc.VARIABLE=VALUE, where:
                //   VARIABLE is alphanumeric + &quot;_&quot;
                //   VALUE does not contain &amp; or #
                var re = /ozpIwc.(\w+)=([^&amp;#]+)/g;
                var m;
                while ((m = re.exec(rawString)) !== null) {
                    var params = decodeURIComponent(m[2]);
                    try {
                        params = JSON.parse(params);
                    } catch (e) {
                        // ignore the errors and just pass through the string
                    }
                    this.launchParams[m[1]] = params;
                }
            },

            /**
             * Receive a packet from the connected peer.  If the packet is a reply, then
             * the callback for that reply is invoked.  Otherwise, it fires a receive event
             *
             * Fires:
             *     - {{#crossLink &quot;ozpIwc.Client/receive:event}}{{/crossLink}}
             *
             * @method receive
             * @protected
             * @param {ozpIwc.packet.Transport} packetContext
             */
            receiveFromRouterImpl: function (packetContext) {
                var handled = false;

                // If no packet, it is likely a $transport packet.
                var packet = packetContext.packet || packetContext;
                //Try and handle this packet as a reply message
                if (packet.replyTo &amp;&amp; this.promiseCallbacks[packet.replyTo]) {

                    var replyCancel = false;
                    var replyDone = function () {
                        replyCancel = true;
                    };
                    this.promiseCallbacks[packet.replyTo](packet, replyDone);

                    if (replyCancel) {
                        this.cancelPromiseCallback(packet.replyTo);
                        handled = true;
                    }

                }

                //Try and handle this packet as callback message
                if (!handled &amp;&amp; packet.replyTo &amp;&amp; this.registeredCallbacks[packet.replyTo]) {

                    var registeredCancel = false;
                    var self = this;
                    var registeredDone = function () {
                        registeredCancel = true;

                        if (self.watchMsgMap[packet.replyTo] &amp;&amp; self.watchMsgMap[packet.replyTo].action === &quot;watch&quot;) {
                            self.api(self.watchMsgMap[packet.replyTo].dst).unwatch(self.watchMsgMap[packet.replyTo].resource);
                        }
                        self.cancelRegisteredCallback(packet.replyTo);
                    };

                    handled = this.registeredCallbacks[packet.replyTo](packet, registeredDone);
                }
                if (!handled) {
                    //Drop own packets
                    if (packet.src === this.address) {
                        return;
                    }

                    if (packet.dst === &quot;$bus.multicast&quot;) {
                        //If not handle-able by the mixin, trigger &quot;busPacket&quot; for someone to handle
                        if (!handleBusPacket(this, packet)) {
                            this.events.trigger(&quot;busPacket&quot;, packetContext);
                        }
                    } else {
                        //Not bus packet, trigger &quot;receive&quot; for someone to handle
                        this.events.trigger(&quot;receive&quot;, packetContext);
                    }
                }
            },

            /**
             * Builds the client api calls from the values in client.apiMap
             *
             * @method constructApiFunctions
             */
            constructApiFunctions: function () {
                for (var api in this.apiMap) {
                    var apiObj = this.apiMap[api];
                    var apiFuncName = apiObj.address.replace(&#x27;.api&#x27;, &#x27;&#x27;);

                    //prevent overriding client constructed fields, but allow updating of constructed APIs
                    if (!this.hasOwnProperty(apiFuncName) || this.apiMap[api].functionName === apiFuncName) {
                        // wrap this in a function to break the closure
                        // on apiObj.address that would otherwise register
                        // everything for the last api in the list
                        /*jshint loopfunc:true*/
                        (function (self, addr) {
                            self[apiFuncName] = function () {
                                return self.api(addr);
                            };
                            self.apiMap[addr] = self.apiMap[addr] || {};
                            self.apiMap[addr].functionName = apiFuncName;
                            self.updateApi(addr);
                        })(this, apiObj.address);
                    }
                }
            },

            /**
             * Calls the names.api to gather the /api/* resources to gain knowledge of available api actions of the
             * current bus.
             *
             * @method gatherApiInformation
             * @return {Promise}
             */
            gatherApiInformation: function () {
                var self = this;
                // gather api information
                return this.send({
                    dst: &quot;names.api&quot;,
                    action: &quot;get&quot;,
                    resource: &quot;/api&quot;
                }).then(function (reply) {
                    if (reply.response === &#x27;ok&#x27;) {
                        return reply.entity;
                    } else {
                        throw reply.response;
                    }
                }).then(function (apis) {
                    var promiseArray = [];
                    apis.forEach(function (api) {
                        var promise = self.send({
                            dst: &quot;names.api&quot;,
                            action: &quot;get&quot;,
                            resource: api
                        }).then(function (res) {
                            if (res.response === &#x27;ok&#x27;) {
                                var name = api.replace(&#x27;/api/&#x27;, &#x27;&#x27;);
                                self.apiMap[name] = self.apiMap[name] || {};
                                self.apiMap[name].address = name;
                                self.apiMap[name].actions = res.entity.actions;
                            } else {
                                throw res.response;
                            }
                        });
                        promiseArray.push(promise);
                    });
                    return Promise.all(promiseArray);
                });
            },

            /**
             * Cancel a reply callback registration.
             * @method cancelPromiseCallback
             * @param (String} msgId The packet replyTo ID for which the callback was registered.
             *
             * @return {Boolean} True if the cancel was successful, otherwise false.
             */
            cancelPromiseCallback: function (msgId) {
                var success = false;
                if (msgId) {
                    delete this.promiseCallbacks[msgId];
                    success = true;
                }
                return success;
            },

            /**
             * Cancel a watch callback registration.
             *
             * @method cancelRegisteredCallback
             * @param (String} msgId The packet replyTo ID for which the callback was registered.
             *
             * @return {Boolean} True if the cancel was successful, otherwise false.
             */
            cancelRegisteredCallback: function (msgId) {
                var success = false;
                if (msgId) {
                    delete this.registeredCallbacks[msgId];
                    delete this.watchMsgMap[msgId];
                    success = true;
                }
                return success;
            },

            /**
             * Registers callbacks
             *
             * @method on
             * @param {String} event The event to call the callback on.
             * @param {Function} callback The function to be called.
             *
             */
            on: function (event, callback) {
                if (event === &quot;connected&quot; &amp;&amp; this.isConnected()) {
                    callback(this);
                    return;
                }
                return this.events.on.apply(this.events, arguments);
            },

            /**
             * De-registers callbacks
             *
             * @method off
             * @param {String} event The event to call the callback on.
             * @param {Function} callback The function to be called.
             *
             */
            off: function (event, callback) {
                return this.events.off.apply(this.events, arguments);
            },

            /**
             * Handles intent invocation packets. Communicates back with the intents.api to operate the in flight
             * intent
             * state machine.
             *
             * @method intentInvocationHandling
             * @param resource {String} The resource of the packet that sent the intent invocation
             * @param inFlightIntent {Object} The in flight intent, used internally to operate the in flight intent
             *     state machine
             * @param callback {Function} The intent handler&#x27;s callback function
             * @return {Promise}
             */
            intentInvocationHandling: function (packet, inFlightIntent, callback) {
                var self = this;
                var res;
                var promiseChain;
                callback = callback || function () {};
                inFlightIntent = inFlightIntent || {};
                if (inFlightIntent.entity) {
                    promiseChain = Promise.resolve(inFlightIntent);
                } else {
                    promiseChain = self.send({
                        dst: &quot;intents.api&quot;,
                        action: &quot;get&quot;,
                        resource: inFlightIntent.resource
                    });
                }
                return promiseChain.then(function (inFlightIntentRes) {
                    res = inFlightIntentRes;
                    if (res.entity.invokePacket.msgId === packet.msgId) {
                        callback(packet);
                        return Promise.reject(&quot;ownInvoke&quot;);
                    }
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            handler: {
                                resource: packet.resource,
                                address: self.address
                            },
                            me: Date.now(),
                            state: &quot;running&quot;
                        }
                    });
                }).then(function () {
                    // Run the intent handler. Wrapped in a promise chain in case the callback itself is async.
                    return callback(res.entity, inFlightIntent);
                }).then(function (result) {
                    // Allow the callback to override the intent state (usefull for preventing intent resolution if
                    // chained operations are performed.
                    if (result &amp;&amp; result.intentIncomplete) {
                        return Promise.resolve();
                    }
                    // Respond to the inflight resource
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            reply: {
                                &#x27;entity&#x27;: result || {},
                                &#x27;contentType&#x27;: res.entity.intent.type
                            },
                            state: &quot;complete&quot;
                        }
                    });
                })[&#x27;catch&#x27;](function (e) {
                    if (e === &quot;ownInvoke&quot;) {
                        //Filter out own invocations (this occurs when watching an invoke state).
                        return;
                    }

                    console.error(&quot;Error in handling intent: &quot;, e, &quot; -- Reporting error on in-flight intent node:&quot;,
                        res.resource);
                    // Respond to the inflight resource
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            reply: {
                                &#x27;entity&#x27;: e.toString() || {},
                                &#x27;contentType&#x27;: &quot;text/plain&quot;
                            },
                            state: &quot;error&quot;
                        }
                    });
                });
            },

            /**
             * Calls the specific api wrapper given an api name specified.
             * If the wrapper does not exist it is created.
             *
             * @method api
             * @param apiName {String} The name of the api.
             * @return {Function} returns the wrapper call for the given api.
             */
            api: function (apiName) {
                return this.wrapperMap[apiName] || this.updateApi(apiName);
            },
            /**
             * Updates the wrapper map for api use. Whenever functionality is added or removed from the apiMap the
             * updateApi must be called to reflect said changes on the wrapper map.
             *
             * @method updateApi
             * @param apiName {String} The name of the api
             * @return {Function} returns the wrapper call for the given api.
             */
            updateApi: function (apiName) {

                /**
                 * Augmentation for Intents Api register. Automatically invokes a registration if the invoke was passed
                 * into the application opening.
                 * @method intentRegisterAugment
                 * @private
                 * @static
                 * @param client
                 * @param message
                 */
                var intentRegisterAugment = function (client, message) {
                    for (var i in client.launchedIntents) {
                        var loadedResource = &#x27;/&#x27; + client.launchedIntents[i].entity.intent.type + &#x27;/&#x27; + client.launchedIntents[i].entity.intent.action;
                        if (message.packet.resource === loadedResource) {
                            client.intentInvocationHandling(message.packet, client.launchedIntents[i], message.callback);
                            delete client.launchedIntents[i];
                        }
                    }
                };

                /**
                 * Augmentation for Intents Api invoke. Wraps callback to remove the callback when reaching
                 * error/complete state.
                 * @method intentRegisterAugment
                 * @private
                 * @static
                 * @param client
                 * @param message
                 */
                var intentInvokeAugment = function (message) {
                    if (message.callback) {
                        var wrappedCallback = message.callback;
                        // Wrap the callback to make sure it is removed when the intent state machine stops.
                        message.callback = function (reply, done) {
                            wrappedCallback(reply, done);
                            reply = reply || {};
                            reply.entity = reply.entity || {};
                            if (reply.entity.state === &quot;error&quot; || reply.entity.state === &quot;complete&quot;) {
                                done();
                            }
                        };
                    }
                };

                /**
                 * Augmentation for Intents Api broadcast. Compiles the results of all intent handlers and then,
                 * returns the responfixese in the promise resolution. Callback acts like invoke callback.
                 * @method intentRegisterAugment
                 * @private
                 * @static
                 * @param client
                 * @param message
                 */
                var intentBroadcastAugment = function (client, message) {
                    var broadcastWrappedCallback = message.callback || function () {};
                    var registeredCallbacks = client.registeredCallbacks;

                    // Wrap the callback to filter out all of the &quot;complete&quot; messages from each handler sent
                    // intended for a promise resolution. Also store all results for the promise resolution.
                    message.callback = function (reply, done) {
                        if (!registeredCallbacks[reply.replyTo]) {
                            return;
                        }
                        var callback = registeredCallbacks[reply.replyTo];
                        var handlers = callback.handlers;
                        var attemptResolve = function (resource) {
                            var handlerIndex = handlers.indexOf(resource);
                            if (handlerIndex &gt; -1) {
                                handlers.splice(handlerIndex, 1);
                            }
                            if (handlers.length === 0) {
                                callback.reply.entity = callback.results;
                                callback.reply.response = &quot;complete&quot;;
                                callback.pRes(callback.reply);
                                done();
                            }
                        };
                        if (reply.response === &quot;complete&quot;) {
                            callback.results = callback.results || {};
                            callback.results[reply.resource] = reply.entity;
                            attemptResolve(reply.resource);

                        } else if (reply.entity &amp;&amp; reply.entity.state === &quot;error&quot; &amp;&amp; client.registeredCallbacks[reply.replyTo]) {
                            attemptResolve(reply.entity.handler.resource);
                        } else {
                            broadcastWrappedCallback(reply, done);
                        }
                    };
                };

                /**
                 * Augmenters for Intent Api specific actions.
                 * @method intentAugment
                 * @private
                 * @static
                 * @param client
                 * @param message {Object}
                 */
                var intentAugment = function (client, message) {
                    switch (message.packet.action) {
                        case &quot;register&quot;:
                            intentRegisterAugment(client, message);
                            break;
                        case &quot;invoke&quot;:
                            intentInvokeAugment(message);
                            break;
                        case &quot;broadcast&quot;:
                            intentBroadcastAugment(client, message);
                            break;

                    }
                };

                /**
                 * Function generator. Generates API functions given a messageBuilder function.
                 * @method augment
                 * @param messageBuilder
                 * @param client
                 * @return {Function}
                 */
                var augment = function (messageBuilder, client) {
                    return function (resource, fragment, otherCallback) {
                        var message = messageBuilder(resource, fragment, otherCallback);


                        if (message.packet.dst === &quot;intents.api&quot;) {
                            intentAugment(client, message);
                        }
                        return client.send(message.packet, message.callback);
                    };
                };

                /**
                 * Function generator. Generates API message formatting functions for a client-destination-action
                 * pairing. These are generated for bulk sending capabilities, since the message needs to be formatted
                 * but not transmitted until desired.
                 *
                 * @method messageBuilderAugment
                 * @param dst
                 * @param action
                 * @param client
                 * @return {Function}
                 */
                var messageBuilderAugment = function (dst, action, client) {
                    return function (resource, fragment, otherCallback) {
                        // If a fragment isn&#x27;t supplied argument #2 should be a callback (if supplied)
                        if (typeof fragment === &quot;function&quot;) {
                            otherCallback = fragment;
                            fragment = {};
                        }
                        var packet = {
                            &#x27;dst&#x27;: dst,
                            &#x27;action&#x27;: action,
                            &#x27;resource&#x27;: resource,
                            &#x27;entity&#x27;: {}
                        };
                        for (var k in fragment) {
                            packet[k] = fragment[k];
                        }
                        var resolve, reject;
                        var sendData = new Promise(function (res, rej) {
                            resolve = res;
                            reject = rej;
                        });

                        sendData.packet = client.fixPacket(packet);
                        sendData.callback = otherCallback;
                        sendData.res = resolve;
                        sendData.rej = reject;
                        return sendData;
                    };
                };

                var wrapper = this.wrapperMap[apiName] || {};
                if (this.apiMap.hasOwnProperty(apiName)) {
                    var api = this.apiMap[apiName];
                    wrapper = {};

                    /**
                     *  All message formatting calls sits inside the API wrapper&#x27;s messageBuilder object. These
                     *  calls will return a formatted message ready to be sent.
                     *  (e.g: data().messageBuilder.set)
                     */
                    wrapper.messageBuilder = {};
                    wrapper.messageBuilder.bulkSend = function (messages, otherCallback) {
                        var packet = {
                            &#x27;dst&#x27;: api.address,
                            &#x27;action&#x27;: &quot;bulkSend&quot;,
                            &#x27;resource&#x27;: &quot;/&quot;,
                            &#x27;entity&#x27;: messages
                        };

                        return {
                            &#x27;packet&#x27;: packet,
                            &#x27;callback&#x27;: otherCallback
                        };
                    };

                    /**
                     * All function calls are on the root level of the API wrapper. These calls will format messages and
                     * then send them to the router.
                     * (e.g: data().set)
                     */
                    wrapper.bulkSend = (function (bulkMessageBuilder, client) {
                        return function (messages) {
                            var message = bulkMessageBuilder(messages);
                            return client.send(message.packet, message.callback);
                        };
                    })(wrapper.messageBuilder.bulkSend, this);

                    /**
                     * Iterate over all mapped function calls and augment their message formatter and function call.
                     */
                    for (var i = 0; i &lt; api.actions.length; ++i) {
                        var action = api.actions[i];
                        wrapper.messageBuilder[action] = messageBuilderAugment(api.address, action, this);
                        wrapper[action] = augment(wrapper.messageBuilder[action], this);
                    }

                    this.wrapperMap[apiName] = wrapper;
                }
                wrapper.apiName = apiName;
                return wrapper;
            },

            /**
             * Applies necessary properties to the packet to be transmitted through the router.
             *
             * @method fixPacket
             * @param {Object} fields
             * @return {Object}
             */
            fixPacket: function (fields) {
                var packet = {
                    ver: 1,
                    src: fields.src || this.address,
                    msgId: fields.msgId || &quot;p:&quot; + this.msgIdSequence++,
                    time: fields.time || new Date().getTime()
                };

                for (var k in fields) {
                    packet[k] = fields[k] || packet[k];
                }

                if (packet.src === &quot;$nobody&quot;) {
                    packet.src = this.address;
                }

                return packet;
            },

            /**
             * Registers callbacks for API request callbacks and promises.
             *
             * @method registerResponses
             * @property {Object} packet
             * @property {Function} callback
             * @property {Function} promiseRes
             * @property {Function} promiseRej
             */
            registerResponses: function (packet, callback, promiseRes, promiseRej) {
                var self = this;
                if (callback) {
                    this.registeredCallbacks[packet.msgId] = function (reply, done) {
                        // We&#x27;ve received a message that was a promise response but we&#x27;ve aready handled our promise
                        // response.
                        if (/(ok).*/.test(reply.response) || /(bad|no).*/.test(reply.response)) {
                            // Do nothing and let it get sent to the event handler (this is to filter out registration
                            // of callback responses)
                            return false;
                        } else if (reply.entity &amp;&amp; reply.entity.inFlightIntent) {
                            self.intentInvocationHandling(packet, reply.entity.inFlightIntent, callback);
                        } else {
                            callback(reply, done);
                        }
                        return true;
                    };
                }

                //respondOn &quot;all&quot;, &quot;error&quot;, or no value (default all) will register a promise callback.
                if (packet.respondOn !== &quot;none&quot;) {
                    this.promiseCallbacks[packet.msgId] = function (reply, done) {
                        if (reply.src === &quot;intents.api&quot; &amp;&amp;
                            (packet.action === &quot;invoke&quot; &amp;&amp; /(ok).*/.test(reply.response)) ||
                            (packet.action === &quot;broadcast&quot; &amp;&amp; /(complete).*/.test(reply.response))) {
                            // dont sent the response to the promise
                        } else if (reply.src === &quot;intents.api&quot; &amp;&amp; packet.action === &quot;broadcast&quot; &amp;&amp; /(pending).*/.test(reply.response)) {
                            //Broadcast request acknowledged and prepares logic ot handle resolving once all runners
                            // finish.
                            if (self.registeredCallbacks[packet.msgId]) {
                                self.registeredCallbacks[packet.msgId].handlers = reply.entity.handlers || [];
                                self.registeredCallbacks[packet.msgId].pRes = promiseRes;
                                self.registeredCallbacks[packet.msgId].reply = reply;
                            }
                            done();
                        } else if (reply.src === &quot;$transport&quot; || /(ok).*/.test(reply.response) || /(complete).*/.test(reply.response)) {
                            done();
                            promiseRes(reply);
                        } else if (/(bad|no).*/.test(reply.response)) {
                            done();
                            promiseRej(reply);
                        } else {
                            // it was not a promise callback
                        }
                    };
                }

                if (packet.action === &quot;watch&quot;) {
                    this.watchMsgMap[packet.msgId] = packet;
                } else if (packet.action === &quot;unwatch&quot; &amp;&amp; packet.replyTo) {
                    this.cancelRegisteredCallback(packet.replyTo);
                }

                if (packet.action === &quot;bulkSend&quot;) {
                    packet.entity.forEach(function (message) {
                        self.registerResponses(message.packet, message.callback, message.res, message.rej);
                    });
                }
            },
            /**
             * Sends a packet through the IWC.
             * Will call the participants sendImpl function.
             *
             * @method send
             * @param {Object} fields properties of the send packet..
             * @param {Function} callback The Callback for any replies. The callback will be persisted if it returns a
             *     truth-like
             * @param {Function} preexistingPromiseRes If this send already has a promise resolve registration, use it
             *     rather than make a new one.
             * @param {Function} preexistingPromiseRej If this send already has a promise reject registration, use it
             *     rather than make a new one. value, canceled if it returns a false-like value.
             */
            send: function (fields, callback, preexistingPromiseRes, preexistingPromiseRej) {
                if (this.sendingBlocked) {
                    return Promise.resolve({response: &quot;dropped&quot;});
                }
                var promiseRes = preexistingPromiseRes;
                var promiseRej = preexistingPromiseRej;
                var promise = new Promise(function (resolve, reject) {

                    if (!promiseRes &amp;&amp; !promiseRej) {
                        promiseRes = resolve;
                        promiseRej = reject;
                    }
                });

                if (!(this.isConnected() || fields.dst === &quot;$transport&quot;)) {
                    // when send is switched to promises, create the promise first and return it here, as well
                    this.preconnectionQueue.push({
                        &#x27;fields&#x27;: fields,
                        &#x27;callback&#x27;: callback,
                        &#x27;promiseRes&#x27;: promiseRes,
                        &#x27;promiseRej&#x27;: promiseRej
                    });
                    return promise;
                }
                var packet = this.fixPacket(fields);
                this.registerResponses(packet, callback, promiseRes, promiseRej);
                this.sendImpl(packet);
                this.sentBytes += packet.length;
                this.sentPackets++;

                return promise;
            },

            /**
             * Generic handler for a bus connection to handle any queued messages &amp; launch data after its connected.
             * @method afterConnected
             * @return {Promise}
             */
            afterConnected: function () {
                var self = this;
                // dump any queued sends, trigger that we are fully connected
                self.preconnectionQueue.forEach(function (p) {
                    self.send(p.fields, p.callback, p.promiseRes, p.promiseRej);
                });
                self.preconnectionQueue = [];
                if (!self.launchParams.inFlightIntent || self.internal) {
                    self.events.trigger(&quot;connected&quot;);
                    return Promise.resolve();
                }

                // fetch the inFlightIntent
                return self.intents().get(self.launchParams.inFlightIntent).then(function (response) {
                    // If there is an inflight intent that has not already been handled (i.e. page refresh driving to
                    // here)
                    if (response &amp;&amp; response.entity &amp;&amp; response.entity.intent) {
                        var launchParams = response.entity.entity || {};
                        if (response.response === &#x27;ok&#x27;) {
                            for (var k in launchParams) {
                                self.launchParams[k] = launchParams[k];
                            }
                        }
                        self.intents().set(self.launchParams.inFlightIntent, {
                            entity: {
                                state: &quot;complete&quot;
                            }
                        });

                        if (self.launchParams.launchData &amp;&amp; self.launchParams.launchData.inFlightIntent) {
                            self.launchedIntents.push(self.launchParams.launchData.inFlightIntent);
                        }
                    }
                    self.events.trigger(&quot;connected&quot;);
                })[&#x27;catch&#x27;](function (e) {
                    console.error(self.launchParams.inFlightIntent, &quot; not handled, reason: &quot;, e);
                    self.events.trigger(&quot;connected&quot;);
                });
            }

        };
    };
//---------------------------------------------------------
// Private Methods
//---------------------------------------------------------

    /**
     * Handles packets received with a destination of &quot;$bus.multicast&quot;.
     * If the packet action isn&#x27;t handled, the function will return falsy.
     *
     * @method handleBusPacket
     * @private
     * @static
     * @param {ozpIwc.api.base.Api} apiBase
     * @param {Object} packetContext
     * @return {*}
     */
    var handleBusPacket = function (mixer, packet) {
        switch (packet.action) {
            case &quot;connect&quot;:
                mixer.events.trigger(&quot;addressConnects&quot;, packet.entity.address, packet);
                return true;
            case &quot;disconnect&quot;:
                mixer.events.trigger(&quot;addressDisconnects&quot;, packet.entity.address, packet);
                return true;
        }
    };

    return ApiPromiseMixin;
}(ozpIwc.apiMap, ozpIwc.log, ozpIwc.util));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
